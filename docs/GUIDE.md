# Создание бизнес-логики заявки на примере заявки на МСП-услугу

В этом документе описываются этапы написания библиотеки с модулем бизнес-логики
заявки на МСП-услугу с помощью готовых инструментов, а также приводятся
вспомогательные сведения о `case_core`, заявках и необходимой инфраструктуре.

## Краткое описание сервиса `case_core`

Сервис `case_core` — это сервис управления заявками на услуги, который
позволяет создавать и обновлять записи заявок и иных сущностей, ассоциированных
с заявками. Одной из главных особенностей сервиса является выделение
бизнес-логики, обрабатывающей заявку, в отдельные библиотеки и динамическая
загрузка этих библиотек, что позволяет осуществлять их обновление «на лету».
Сервис предоставляет бизнес-логике API для отправки сообщений в очереди СМЭВ,
API для REST-запросов ко внешним ресурсам, а также иные вспомогательные
инструменты.

## Сведения о жизненном цикле заявки на услугу

### Состояние заявки

Центральным аспектом бизнес-логики заявки является жизненный цикл заявки от
создания до закрытия. Жизненный цикл предполагает выделение некоторого атрибута
заявки, который называется статусом или состоянием и может принимать некоторые
дискретные предопределённые значения. Из значения этого атрибута делается вывод
о том, в какой части своего жизненного цикла находится заявка. Вообще говоря,
состояние заявки можно понимать в более широком смысле, учитывая всю
совокупность атрибутов заявки, но в программировании этот подход неудобен в
силу массивности получающегося множества состояний, потому состояние заявки
сводят к единственному атрибуту.

### Граф переходов состояний

Жизненный цикл заявки удобно описывать в виде конечного автомата, множеством
состояний которого является множество состояний заявки с добавленным состоянием
«Состояние отсутствует», которое является начальным для автомата. Входным
алфавитом такого конечного автомата является множество событий, например,
выдача заявки (фактическим событием является нажатие оператором кнопки «Закрыть
заявку» в интерфейсе модуля «Выдача результата») или ответное сообщение СМЭВ.
Одним из способов описания конечного автомата заключается в нарисовании так
называемого графа переходов состояний, то есть ориентированного графа, у
которого вершинами являются состояния автомата, а дугам взаимно однозначно
соответствуют элементы входного алфавита (то есть события).

### Изменение состояния заявки

Бизнес-логика заявки оперирует не только состоянием заявки, но и другими
атрибутами, кроме того, в некоторых случаях необходимо создать запрос ко
внешнему ресурсу или сообщение СМЭВ. Подобные действия ассоциируются с
переходом по дуге графа переходов состояний. Бизнес-логика может также
ассоциировать с дугой некоторое условие на атрибуты заявки, что расширяет
входной алфавит конечного автомата.

### Жизненный цикл заявки на МСП-услугу

Рассмотрим граф переходов состояний заявки на МСП услугу:

```
   +-+   A   +------------+   B1  +-------+
   | |------>| processing |------>| error |
   +-+       +------------+       +-------+
                |      |
                | B2   | B3
                |      V
                |   +----------+
                |   | issuance |
                |   +----------+
                |      |
                |      | C
                V      V
               +--------+
               | closed |
               +--------+
```

В вершинах графа отмечены состояния и отсутствие состояния, а над дугами —
соответствующие события. Состояния интерпретируются следующим образом:
*   `processing` — обработка заявки;
*   `issuance` — выдача результата заявки;
*   `error` — при обработке заявки произошла ошибка;
*   `closed` — заявка закрыта.

События означают следующее.
*   `A` — создание записи заявки (событие сервиса). Приводит к созданию
    сообщения СМЭВ с межведомственным запросом.
*   `B1` — пришёл ответ СМЭВ, сигнализирующий об ошибке.
*   `B2` — пришёл положительный ответ СМЭВ, при этом результат оказания услуги
    необходимо направить по адресу электронной почты заявителя. При этом
    необходимо отметить дату и время выставления нового состояния заявки.
*   `B3` — пришёл положительный ответ СМЭВ, при этом результат оказания услуги
    необходимо выдать заявителю.
*   `C` — результат оказания услуги выдан заявителю. При этом необходимо
    отметить дату и время выставления нового состояния заявки.

Таким образом, описание графа состояний заявки на МСП-услугу не должно
ограничиваться описанием состояний и переходов, так как необходимо также
указать действия после выставления нового состояния и то, какие атрибуты заявки
какие значения должны получить.

## Пользовательские и системные события

Основным интерфейсом бизнес-логики для получения информации о событиях являются
функции модуля бизнес-логики. Сервис использует следующие функции модуля, если
они предоставлены:
*   `on_load` — загрузка модуля;
*   `on_unload` — выгрузка модуля;
*   `on_case_creation` — создание записи заявки;
*   `on_responding_stomp_message` — входящее сообщение STOMP.
Кроме того, модуль может предоставлять дополнительные функции, которые могут
вызываться через механизм удалённого вызова (RPC). Так, например, обработку
события `C` в жизненном цикле заявки на МСП-услугу можно осуществить с помощью
дополнительной функции, вызывая её из приложения, в котором работает оператор,
который выдаёт результат оказания услуги.

## Начало создания библиотеки

Для библиотеки понадобится отдельный проект `msp_case` в Gitlab и базовая
инфраструктура для развёртывания виртуальной машины, запуска тестов и сборки
библиотеки с бизнес-логикой. Расположим модуль бизнес-логики в файле
`lib/msp_case.rb` и определим в нём следующие функции:
```ruby
module MSPCase
  def self.change_state_to(c4s3, state, params)
  end

  def self.on_case_creation(c4s3)
  end

  def self.on_responding_stomp_message(message)
    false
  end
end
```

Реализация функций может разниться от библиотеки к библиотеке. Вообще говоря,
сервис не накладывает никаких ограничений на реализацию за исключением того,
что библиотека не может использовать посторонние решения, кроме тех, что
прописаны в сервисе (`activesupport`, `rufus-scheduler` и некоторые другие).
Отметим, что эти функции полностью покрывают жизненный цикл заявки на
МСП-услугу.

## Обработка событий ручного изменения состояния

В жизненном цикле заявки можно выделить события, созданные в результате ручного
действия человека, например, нажатие на кнопку «Создать заявку» приводит к
вызову функции `on_case_creation` или нажатие на кнопку «Закрыть» приводит к
вызову функции `change_state_to` с соответствующим аргументом (при должной
реализации). К этой категории относятся события `A` и `C` графа переходов
состояния заявки на МСП-услугу. Для их описания портируем движок обработчика
подобных событий из класса `MFCCase::Base::StateDrivenFSA` в класс
`MSPCase::Base::StateDrivenFSA`. Этот движок предлагает язык для описания
переходов и действий, связанных с ними, при этом его возможности шире, чем
необходимые нам. Вообще говоря, при портировании мы можем урезать возможности
движка, убрав поддержку конструкций `check` и `raise`. После портирования можно
использовать движок, создав описания переходов в файле
`lib/msp_case/change_state_to.rb`:
```ruby
load "#{__dir__}/base/state_driven_fsa.rb"

module MSPCase
  class ChangeStateTo < Base::StateDrivenFSA
    load "#{__dir__}/change_state_to/create_request.rb"

    # A
    edge nil:   :processing,
         need:  %w(special_data service_id),
         after: CreateRequest

    # C
    edge issuance: :closed,
         set:      { closed_at: :now }
  end
end
```
Первый аргумент конструкции `edge` описывает из какого состояния в какое идёт
дуга. Значение `nil` указывает на отсутствие состояния. Далее, эта конструкция
поддерживает следующие параметры:
*   `need` — атрибуты, которые необходимо извлечь перед обработкой перехода;
*   `after` — операция, которую необходимо осуществить после обновления
    атрибутов заявки;
*   `set` — ассоциативный массив с информацией о новых значениях атрибутов.

В файле `lib/msp_case/change_state_to/create_request.rb` необходимо создать
модуль `MSPCase::ChangeStateTo::CreateRequest`, предоставляющий функцию `call`,
которая принимает запись заявки и ассоциативный массив её аргументов в качестве
аргументов:
```ruby
require 'securerandom'

module MSPCase
  class ChangeStateTo
    module CreateRequest
      def self.call(c4s3, case_attributes)
        message_id = SecureRandom.uuid
        request = CaseCore::Actions::Requests
                  .create(case_id: c4s3.id, msp_message_id: message_id)
        publish_message(case_attributes, message_id)
      end

      QUEUE_NAME = 'smev3.queue'

      def self.publish_message(case_attributes, message_id)
        message = message_data(case_attributes, message_id).to_json
        CaseCore::API::STOMP::Controller.publish(QUEUE_NAME, message, {})
      end

      def self.message_data(case_attributes, message_id)
        {
          id:      message_id,
          content: case_attributes.slice(:special_data, :service_id)
        }
      end
    end
  end
end
```

Теперь можно добавить реализацию обработчиков событий:
```ruby
load "#{__dir__}/msp_case/change_state_to.rb"

module MSPCase
  def self.change_state_to(c4s3, state, params)
    ChangeStateTo.new(c4s3, state, params).process
  end

  def self.on_case_creation(c4s3)
    ChangeStateTo.new(c4s3, 'processing', {}).process
  end

  def self.on_responding_stomp_message(message)
    false
  end
end
```

## Обработка сообщений СМЭВ

Кроме ручного изменения состояния заявки можно также выделить изменение
состояния заявки при обработке сообщений СМЭВ. Так, к событиям, связанными с
сообщениями СМЭВ, можно отнести события `B1`, `B2`, `B3` графа переходов
состояния заявки на МСП-услугу. Для описания переходов можно портировать движок
обработчика событий ручного изменения состояния заявки. Можно выделить
следующие отличия, требующие проработки при портированиию.
1.  Сообщения СМЭВ несут информацию о том, произошла ли ошибка при запросе, был
    ли запрос принят или отклонён. Поэтому необходим параметр, значение
    которого указывает на то, каков формат обрабатываемого сообщения СМЭВ для
    данной дуги.
2.  Необходимо учесть условие на дугу с помощью некоторого параметра.

Портирование движка выходит за рамки этого документа (пример готовой
реализации можно найти в том же проекте `msp_case`), потому приведём только
готовое описание переходов:
```ruby
load "#{__dir__}/base/message_driven_fsa.rb"

module MSPCase
  class RespondToMessage < Base::MessageDrivenFSA
    # B1
    edge processing: :error,
         on:         :exception

    # B2
    edge processing: :closed,
         on:         %w(rejection response),
         if:         -> { issue_location_type == 'email' },
         need:       %w(issue_location_type),
         set:        { closed_at: :now }

    # B3
    edge processing: :issuance,
         on:         %w(rejection response),
         if:         -> { issue_location_type == 'mfc' },
         need:       %w(issue_location_type)
  end
end
```

Результирующее описание обработчиков переходов может выглядеть следующим
образом:
```ruby
require 'active_support/core_ext/hash/slice.rb'
require 'active_support/core_ext/object/blank.rb'
require 'active_support/core_ext/string/filters.rb'
require 'json'
require 'json-schema'

load "#{__dir__}/msp_case/change_state_to.rb"
load "#{__dir__}/msp_case/respond_to_message.rb"

module MSPCase
  def self.change_state_to(c4s3, state, params)
    ChangeStateTo.new(c4s3, state, params).process
  end

  def self.on_case_creation(c4s3)
    ChangeStateTo.new(c4s3, 'processing', {}).process
  end

  def self.on_responding_stomp_message(message)
    RespondToMessage.new(message).process
    true
  rescue
    false
  end
end
```
